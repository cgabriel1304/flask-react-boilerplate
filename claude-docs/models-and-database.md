# Models & Database Guidelines

## ORM

SQLAlchemy 2.0 via Flask-SQLAlchemy. The `db` instance is created in `app.py` and shared across the app.

## BaseModel

All models must inherit from `BaseModel` (defined in `models.py`):

```python
class BaseModel(db.Model):
    __abstract__ = True
    id = db.Column(db.Integer, primary_key=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

    def to_dict(self):
        return {
            'id': self.id,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
        }
```

### Creating a New Model

1. Define the model in `models.py` inheriting from `BaseModel`
2. Set `__tablename__` explicitly
3. Override `to_dict()` calling `super().to_dict()` and extending with model-specific fields
4. Import the model in `migrations/env.py` so Alembic detects it for autogeneration

```python
class User(BaseModel):
    __tablename__ = 'users'
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)

    def to_dict(self):
        data = super().to_dict()
        data.update({
            'username': self.username,
            'email': self.email,
        })
        return data
```

## Migrations (Alembic)

Alembic is configured in `backend/alembic.ini` with migration scripts in `backend/migrations/`.

### Workflow

```bash
# After modifying models:
alembic revision --autogenerate -m "Add users table"

# Apply to database:
alembic upgrade head

# Rollback one step:
alembic downgrade -1

# Check current version:
alembic current

# View migration history:
alembic history
```

### Important Notes

- `migrations/env.py` reads `target_metadata` from `db.metadata` — new models are detected automatically **only if imported** before Alembic runs
- The env.py reads `FLASK_ENV` to determine which database URL to use
- Always review autogenerated migrations before applying — check for unintended drops or renames
- Migration versions directory is at `migrations/versions/` (currently empty)

## Database Connections

| Environment | Database | Source |
|---|---|---|
| Development | PostgreSQL | `DATABASE_URL` in `.env`, falls back to `postgresql://cyberitance:cyberitance_pass@localhost:5432/cyberitance` |
| Testing | SQLite in-memory | Hardcoded in `TestingConfig` |
| Production | PostgreSQL | `DATABASE_URL` env var (required) |

## Session Management

- Use `db.session` for all database operations
- The 500 error handler in `app.py` calls `db.session.rollback()` automatically
- In tests, the `db` fixture handles `session.remove()` and `drop_all()` after each test
- Commit explicitly with `db.session.commit()` — Flask-SQLAlchemy does not auto-commit

## Conventions

- Use `db.String(n)` with explicit length limits
- Set `nullable=False` for required fields
- Add `unique=True` constraints where appropriate
- Use `db.relationship()` with `backref` or `back_populates` for associations
- Name foreign key columns as `<related_table_singular>_id` (e.g., `user_id`)
- Name tables as lowercase plural (e.g., `users`, `policies`)
